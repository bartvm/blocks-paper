\documentclass[twoside,11pt]{article}

% Any additional packages needed should be included after jmlr2e.
% Note that jmlr2e.sty includes epsfig, amssymb, natbib and graphicx,
% and defines many common macros, such as 'proof' and 'example'.
%
% It also sets the bibliographystyle to plainnat; for more information on
% natbib citation styles, see the natbib documentation, a copy of which
% is archived at http://www.jmlr.org/format/natbib.pdf

\usepackage{jmlr2e}
\usepackage{hyperref}

\usepackage{courier}
\usepackage{listings}
\usepackage{todonotes}
\lstset{basicstyle=\footnotesize\ttfamily}

% Heading arguments are {volume}{year}{pages}{submitted}{published}{author-full-names}

% \jmlrheading{1}{2015}{?-??}{5/15}{??/??}{Bart van Merri\"{e}nboer, Dzmitry
% Bahdanau, Jan Chorowski, Vincent Dumoulin, Dmitriy Serdyuk, David
% Warde-Farley, and Yoshua Bengio}

% Short headings should be running head and authors last names

\ShortHeadings{Blocks and Fuel}{Van Merri\"{e}nboer et al.}
\firstpageno{1}

\begin{document}

\title{Blocks and Fuel: GPU-accelerated neural networks for large data}

\author{\name Bart van Merri\"{e}nboer \email bart.van.vanmerrienboer@umontreal.ca \\
        \addr Montreal Institute for Learning Algorithms, University of Montreal, Montreal, Canada
        \AND
        \name Dzmitry Bahdanau \email d.bahdanau@jacobs-university.de \\
        \addr Jacobs University, Bremen, Germany
        \AND
        \name Jan Chorowski \email jan.chorowski@ii.uni.wroc.pl \\
        \addr University of Wroc\l aw, Wroc\l aw, Poland
        \AND
        \name Vincent Dumoulin \email dumouliv@iro.umontreal.ca \\
        \name Dmitriy Serdyuk \email serdyuk.dmitriy@gmail.com \\
        \name David Warde-Farley \email wardefar@iro.umontreal.ca \\
        \name Yoshua Bengio \email yoshua.bengio@umontreal.ca \\
        \addr Montreal Institute for Learning Algorithms, University of Montreal, Montreal, Canada}

% \editor{?}

\maketitle

\begin{abstract}%   <- trailing '%' for backward compatibility of .sty file
  We introduce two Python frameworks to train neural networks on large
  datasets: \emph{Blocks} and \emph{Fuel}. \emph{Blocks} is based on the
  Theano, a linear algebra compiler with
  CUDA-support~\citep{Bastien-Theano-2012,bergstra+al:2010-scipy}. It
  facilitates the training of complex neural network models by providing
  parametrized Theano operations, attaching metadata to Theano's symbolic
  computation graph, and providing an extensive set of utilities to assist
  training the networks, e.g.\ training algorithms, logging, monitoring,
  visualization, and serialization. \emph{Fuel} provides a standard format for
  machine learning datasets. It allows the user to easily iterate over large
  datasets, performing many types of pre-processing on the fly.
\end{abstract}

\begin{keywords}
  Neural networks, GPGPU, large-scale machine learning
\end{keywords}

\section{Introduction}

\emph{Blocks} and \emph{Fuel} are being developed by the Montreal Institute of
Learning Algorithms (MILA) at the University of Montreal. Their focus lies on
quick prototyping of complex neural network models. The intended target
audience is researchers.

Several other libraries built on top of Theano exist, including Pylearn2 (also
developed by MILA), Lasagne, Keras and GroundHog. Blocks differentiates itself
with a strong focus on research, and through its relationship with Theano.
Instead of introducing new abstract objects representing `models' or `layers',
Blocks annotates the Theano computation graph, maintaining the flexibility of
Theano while making large models manageable.

Data processing is an integral part of training neural networks, which is not
addressed by many of the aforementioned frameworks. \emph{Fuel}, inspired by
projects such as \textsc{skdata}\footnote{https://jaberg.github.io/skdata/},
aims to fill this gap.

\section{Blocks}

Theano is a popular choice for the implementation of neural networks (see
e.g.~\cite{Goodfellow-et-al-ICML2013, Pascanu-et-al-ICML2013}). Blocks and many
other libraries, such as Pylearn2~\cite{pylearn2_arxiv_2013}, build on Theano
by providing reusable components that are common in neural networks, such as
linear transformations followed by non-linear activations, or more complicated
components such as LSTM units. In Blocks these components are referred ot as
\emph{bricks} or ``parametrized Theano operations''.

Bricks take the form of a set of parameters in the form of Theano shared
variables, for example the weight matrix of a linear transformation or the
filters of a convolutional layer. Bricks use these parameters to transform
symbolic Theano variables, potentially in multiple ways.

Bricks can contain other bricks within them. This effectively introduces a
hierarchy of structures on top of the flat computation graph defined by Theano,
which makes it easier to address and configure complex models programmatically.

The parameters of bricks can be initialized using a variety of schemes that are
popular in the neural network literature, such as sparse initialization,
orthogonal initialization for recurrent weights, etc.

Large neural networks can often result in Theano computation graphs containing
hundreds of variables and operations. Blocks does not attempt to abstract away
this complex graph, but to make it manageable by annotating variables in the
graph. Each input, output, and parameter of a brick is annotated as such.
Variables can also be annotated with the role they play in a model, such as
\emph{weights}, \emph{biases}, \emph{filters}, etc. A series of convenience
tools were written that allow users to filter the symbolic computation graph
based on these annotations, resulting in an approach that allows for powerful
queries such as ``Apply weight noise to all weights that belong to an LSTM
unit whose parent is a brick with the name \ldots''

Blocks comes with a large number of `bricks'. Besides standard activations and
transformations used in feedforward networks (maxout, convolutional layers,
table lookups) these also include a variety of more advanced recurrent neural
network (RNN) bricks (LSTM, GRU, support for `attention mechanisms').

\todo[inline]{Code sample to show Blocks' syntax?}

\section{Fuel}

Fuel's goal is to provide a common interface to a variety of data formats and
published datasets such as MNIST, CIFAR-10, ImageNet, etc.\ while making it easy
for users to write an interface to new datasets. Fuel allows for different ways
of iterating over these datasets, such as sequential or shuffled minibatches,
support for in-memory and out-of-core datasets, and resampling (cross
validation, bootstrapping). It also provides a variety of on-the-fly
preprocessing methods such as random cropping of images, creating n-grams from
text files, and the ability to implement many other methods easily.

Blocks relies on Fuel for its data interface, but Fuel can easily be used by
other machine learning frameworks that interface with datasets.

\subsection{Standardized data format}

Fuel concentrates most of its built-in datasets around one common interface:
HDF5. In addition to being an efficient format for large datasets that don't
fit into memory, HDF5 is very easy to organize and document. This allows to
simplify dataset storage by putting everything into one file and documenting
how this file is organized with metadata.

The main class for interfacing with HDF5 datasets is the \lstinline$H5PYDataset$
class. Given a series of assumptions about how data is organized within an HDF5
file, it is able to parse:

\begin{itemize}
\item What are the data sources available (e.g.\ features, targets, etc.)?
\item How are these data sources officially split (e.g.\ training, test sets)?
\item Are some data sources unavailable for some splits (e.g.\ test set only
      offers unlabeled examples)?
\item What are the axes semantics for a given data source (e.g.\ batch, feature,
      width, height, channel, time, etc.)?
\end{itemize}

\todo[inline]{Explain these assumptions in more details?}

This class is flexible enough that most built-in datasets are little more than a
wrapper that defines the default location of the dataset file and some sensible
transformations to apply to the data by default. Integrating user data into Fuel
is also very straightforward if these assumptions are respected.

For small datasets that fit into memory, reading off disk is inefficient.
\lstinline$H5PYDataset$ supports loading data into memory with the use of a
\lstinline$load_in_memory$ constructor argument.

\subsection{Automated data management}

Fuel offers built-in scripts that automate the task of downloading and
converting raw data files.

The \lstinline$fuel-download$ script is used to download raw data files.
Downloading the raw MNIST data files is as easy as typing
\lstinline$fuel-download mnist$. Under the hood, \lstinline$fuel-download$ uses
the \lstinline$argparse$ module along with subparsers so that each built-in
dataset can define its own specific command-line arguments. For instance,
datasets whose download URL is not publicly available could require that
the URL is passed as argument to \lstinline$fuel-download$.

The \lstinline$fuel-convert$ script is used to convert raw data files into a
format that Fuel understands, which for most cases is the aforementioned HDF5
format. Converting the raw MNIST data files into an HDF5 file translates to the
the \lstinline$fuel-convert mnist$ command. Like for \lstinline$fuel-convert$,
\lstinline$fuel-download$ uses \lstinline$argparse$ along with subparsers for
flexibility. This feature is especially handy for large datasets with no
standardized preprocessing, such as ImageNet.

Reproducibility being a very important feature in research, the
\lstinline$fuel-convert$ script automatically tags all files it creates with
relevant module and interface versions and the exact command that was used to
generate these files. Inspection of this metadata is done with the
\lstinline$fuel-info$ script.

\section{Serialization and checkpointing}

The training of large, deep neural networks can often take days or even weeks.
Hence, regular checkpointing of training progress is important. Blocks aims to
make the resumption of experiments entirely transparent, even across platforms,
while ensuring the reproducibility of these experiments.

This goal is complicated by shortcomings in Python's \textsc{Pickle}
serialization module, which is unable to serialize many iterators, which Fuel
heavily depends on in order to iterate over large datasets efficiently. To
circumvent this we reimplemented the \textsc{itertools} from the Python
standard library to be serializable.

As a result, Blocks experiments are able to be interrupted in the middle of a
pass over the dataset, serialized, and resumed later, without affecting the
final training results.

\section{Documentation and community}

Blocks and Fuel are well documented, with both API documentation and tutorials
available online. Two active mailing
lists\footnote{\url{https://groups.google.com/d/forum/blocks-users} and
\url{https://groups.google.com/d/forum/fuel-users}} support users of the
libraries. A separate
repository\footnote{\url{https://github.com/mila-udem/blocks-examples}} is
maintained for users to contribute non-trivial examples of the use of Blocks.
Implementations of neural machine translation models
(NMT,~\cite{bahdanau2015neural}) and the Deep Recurrent Attentive Writer
(DRAW,~\cite{gregor2015draw}) model are publicly available examples of
state-of-the-art models succesfully implemented using Blocks.

\acks{The authors would like to acknowledge the support of the following
  agencies for research funding and computing support: NSERC, Calcul Qu\'{e}bec,
  Compute Canada, the Canada Research Chairs and CIFAR\@. We would also like to
  thank the developers of Theano.}

\bibliography{bibliography}

\end{document}
